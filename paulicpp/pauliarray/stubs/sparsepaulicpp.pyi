import collections.abc
import typing

def and_dpoint(arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]], arg1: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]]) -> list[tuple[int, int]]: ...
def generate_random_vec(arg0: typing.SupportsInt, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -> list[int]: ...
def make_dpoint(arg0: collections.abc.Sequence[typing.SupportsInt]) -> list[tuple[int, int]]: ...
def not_dpoint(arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]], arg1: typing.SupportsInt) -> list[tuple[int, int]]: ...
def or_dpoint(arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]], arg1: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]]) -> list[tuple[int, int]]: ...
def overlap_dpoint(arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]], arg1: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]]) -> None: ...
def popcount_dpoint(arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]]) -> int: ...
def show_dpoints(arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]]) -> None: ...
def xor_dpoint(arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]], arg1: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]]) -> list[tuple[int, int]]: ...
