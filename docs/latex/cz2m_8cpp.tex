\doxysection{z2r\+\_\+accel/\+\_\+core/src/cz2m.cpp File Reference}
\hypertarget{cz2m_8cpp}{}\label{cz2m_8cpp}\index{z2r\_accel/\_core/src/cz2m.cpp@{z2r\_accel/\_core/src/cz2m.cpp}}
{\ttfamily \#include "{}cz2m.\+h"{}}\newline
Include dependency graph for cz2m.\+cpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{cz2m_8cpp__incl}
\end{center}
\end{figure}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8cpp_a9462b2d1d2e54e82ad72c6d30f03230c}{tensor}} (py\+::array z2, py\+::array x2, py\+::array z1, py\+::array x1)
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8cpp_a66c4da901dc2803db3fd403a21934220}{compose}} (py\+::array z1, py\+::array x1, py\+::array z2, py\+::array x2)
\item 
py\+::array\+\_\+t$<$ bool $>$ \mbox{\hyperlink{cz2m_8cpp_a0f8b9ce6d2fd5c3b15c38b12727994f9}{bitwise\+\_\+commute\+\_\+with}} (py\+::array z1, py\+::array x1, py\+::array z2, py\+::array x2)
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8cpp_a0495c869623fb769f74386e502b297fc}{random\+\_\+zx\+\_\+strings}} (const std\+::vector$<$ size\+\_\+t $>$ \&shape)
\item 
py\+::object \mbox{\hyperlink{cz2m_8cpp_aabe6109d5005c80e869f322975d474a4}{unique}} (py\+::array zx\+\_\+voids, bool return\+\_\+index, bool return\+\_\+inverse, bool return\+\_\+counts)
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8cpp_ae4da4fa68c447ad16c8312e9e6938628}{unordered\+\_\+unique}} (py\+::array zx\+\_\+voids)
\begin{DoxyCompactList}\small\item\em This is a very early test implementation of unordered unique. It finds unique rows in a Num\+Py 2D array by mapping the zx\+\_\+voids to a hashmap. Thus, two identical rows will be encoded to the same key via the hashing function and ensures a fast execution time. \end{DoxyCompactList}\item 
py\+::array \mbox{\hyperlink{cz2m_8cpp_ae6f7178fc35327a981af856ca64fbc16}{row\+\_\+echelon}} (py\+::array voids, int num\+\_\+qubits)
\begin{DoxyCompactList}\small\item\em applies Gauss-\/\+Jordan elimination on a binary matrix to produce row echelon form \end{DoxyCompactList}\item 
std\+::tuple$<$ std\+::vector$<$ int $>$, std\+::vector$<$ int $>$, std\+::vector$<$ std\+::complex$<$ double $>$ $>$ $>$ \mbox{\hyperlink{cz2m_8cpp_ac4ad30cf11f525fd9d8edf274e2b746f}{sparse\+\_\+matrix\+\_\+from\+\_\+zx\+\_\+voids}} (py\+::array z\+\_\+voids, py\+::array x\+\_\+voids, int num\+\_\+qubits)
\item 
std\+::vector$<$ std\+::complex$<$ double $>$ $>$ \mbox{\hyperlink{cz2m_8cpp_aac70a6a63284d6acd98f2c5cf2c67b0f}{get\+\_\+phases}} (py\+::array z\+\_\+voids, py\+::array x\+\_\+voids)
\item 
py\+::array\+\_\+t$<$ std\+::complex$<$ double $>$ $>$ \mbox{\hyperlink{cz2m_8cpp_a375f5fbabed5082337c4f714f68bedd3}{to\+\_\+matrix}} (py\+::array z\+\_\+voids, py\+::array x\+\_\+voids, int num\+\_\+qubits)
\item 
py\+::array \mbox{\hyperlink{cz2m_8cpp_a12fbfe079cede36f161a30220eec6d97}{transpose}} (py\+::array voids, int64\+\_\+t num\+\_\+bits)
\begin{DoxyCompactList}\small\item\em Transposes a technically 1D array of voids by interpreting it as a 2D array of bits. In other words, if the input array has shape (M,) and each element has N bits, the output array will have shape (N, M), where the rows correspond to the bits of the input elements. \end{DoxyCompactList}\item 
py\+::array \mbox{\hyperlink{cz2m_8cpp_a3c6e4cb97bf8045d53f0c6d4b48e834c}{matmul}} (py\+::array z2r\+\_\+a, py\+::array z2r\+\_\+b, int a\+\_\+num\+\_\+qubits, int b\+\_\+num\+\_\+qubits)
\begin{DoxyCompactList}\small\item\em Matrix multiplication of two void arrays (technically 1D), interpreted as 2D bit matrices. \end{DoxyCompactList}\item 
py\+::array \mbox{\hyperlink{cz2m_8cpp_ac5e25849d7db6f59bb064c56f6ca88dd}{concatenate}} (py\+::array x1, py\+::array x2, int axis)
\item 
py\+::array\+\_\+t$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{cz2m_8cpp_a5eca29d13c97b572644a145d68451347}{z2\+\_\+to\+\_\+uint8}} (py\+::array z2r, int num\+\_\+bits)
\item 
py\+::array \mbox{\hyperlink{cz2m_8cpp_a410809120b7e19dd834d0eacf8314d4b}{gauss\+\_\+jordan\+\_\+inverse}} (py\+::array z2r, int num\+\_\+bits)
\begin{DoxyCompactList}\small\item\em Calculates the inverse of a matrix (if possible) using Gauss-\/\+Jordan elimination. This function will not work on a matrix if \+: \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{cz2m_8cpp_a0f8b9ce6d2fd5c3b15c38b12727994f9}\label{cz2m_8cpp_a0f8b9ce6d2fd5c3b15c38b12727994f9} 
\index{cz2m.cpp@{cz2m.cpp}!bitwise\_commute\_with@{bitwise\_commute\_with}}
\index{bitwise\_commute\_with@{bitwise\_commute\_with}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{bitwise\_commute\_with()}{bitwise\_commute\_with()}}
{\footnotesize\ttfamily py\+::array\+\_\+t$<$ bool $>$ bitwise\+\_\+commute\+\_\+with (\begin{DoxyParamCaption}\item[{py\+::array}]{z1,  }\item[{py\+::array}]{x1,  }\item[{py\+::array}]{z2,  }\item[{py\+::array}]{x2 }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_a66c4da901dc2803db3fd403a21934220}\label{cz2m_8cpp_a66c4da901dc2803db3fd403a21934220} 
\index{cz2m.cpp@{cz2m.cpp}!compose@{compose}}
\index{compose@{compose}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{compose()}{compose()}}
{\footnotesize\ttfamily py\+::tuple compose (\begin{DoxyParamCaption}\item[{py\+::array}]{z1,  }\item[{py\+::array}]{x1,  }\item[{py\+::array}]{z2,  }\item[{py\+::array}]{x2 }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_ac5e25849d7db6f59bb064c56f6ca88dd}\label{cz2m_8cpp_ac5e25849d7db6f59bb064c56f6ca88dd} 
\index{cz2m.cpp@{cz2m.cpp}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{concatenate()}{concatenate()}}
{\footnotesize\ttfamily py\+::array concatenate (\begin{DoxyParamCaption}\item[{py\+::array}]{x1,  }\item[{py\+::array}]{x2,  }\item[{int}]{axis }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_a410809120b7e19dd834d0eacf8314d4b}\label{cz2m_8cpp_a410809120b7e19dd834d0eacf8314d4b} 
\index{cz2m.cpp@{cz2m.cpp}!gauss\_jordan\_inverse@{gauss\_jordan\_inverse}}
\index{gauss\_jordan\_inverse@{gauss\_jordan\_inverse}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{gauss\_jordan\_inverse()}{gauss\_jordan\_inverse()}}
{\footnotesize\ttfamily py\+::array gauss\+\_\+jordan\+\_\+inverse (\begin{DoxyParamCaption}\item[{py\+::array}]{z2r,  }\item[{int}]{num\+\_\+bits }\end{DoxyParamCaption})}



Calculates the inverse of a matrix (if possible) using Gauss-\/\+Jordan elimination. This function will not work on a matrix if \+: 


\begin{DoxyItemize}
\item It is not "{}2\+D"{}, as in a 1D list of packed voids
\item It is not "{}square"{} (num\+\_\+qubits == number of rows)
\item It is inconsistant with its dtype and num\+\_\+qubits
\item It is is singular, i.\+e inatly does not have a inverse If an input is bad, a runtime error will be thrown and function exited. TODO\+: rename function variables to something less ass
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em z2r} & \\
\hline
{\em num\+\_\+bits} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array 
\end{DoxyReturn}
\Hypertarget{cz2m_8cpp_aac70a6a63284d6acd98f2c5cf2c67b0f}\label{cz2m_8cpp_aac70a6a63284d6acd98f2c5cf2c67b0f} 
\index{cz2m.cpp@{cz2m.cpp}!get\_phases@{get\_phases}}
\index{get\_phases@{get\_phases}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{get\_phases()}{get\_phases()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::complex$<$ double $>$ $>$ get\+\_\+phases (\begin{DoxyParamCaption}\item[{py\+::array}]{z\+\_\+voids,  }\item[{py\+::array}]{x\+\_\+voids }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_a3c6e4cb97bf8045d53f0c6d4b48e834c}\label{cz2m_8cpp_a3c6e4cb97bf8045d53f0c6d4b48e834c} 
\index{cz2m.cpp@{cz2m.cpp}!matmul@{matmul}}
\index{matmul@{matmul}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{matmul()}{matmul()}}
{\footnotesize\ttfamily py\+::array matmul (\begin{DoxyParamCaption}\item[{py\+::array}]{z2r\+\_\+a,  }\item[{py\+::array}]{z2r\+\_\+b,  }\item[{int}]{a\+\_\+num\+\_\+qubits,  }\item[{int}]{b\+\_\+num\+\_\+qubits }\end{DoxyParamCaption})}



Matrix multiplication of two void arrays (technically 1D), interpreted as 2D bit matrices. 


\begin{DoxyParams}{Parameters}
{\em z2r\+\_\+a} & \\
\hline
{\em z2r\+\_\+b} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array 
\end{DoxyReturn}
\Hypertarget{cz2m_8cpp_a0495c869623fb769f74386e502b297fc}\label{cz2m_8cpp_a0495c869623fb769f74386e502b297fc} 
\index{cz2m.cpp@{cz2m.cpp}!random\_zx\_strings@{random\_zx\_strings}}
\index{random\_zx\_strings@{random\_zx\_strings}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{random\_zx\_strings()}{random\_zx\_strings()}}
{\footnotesize\ttfamily py\+::tuple random\+\_\+zx\+\_\+strings (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{shape }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_ae6f7178fc35327a981af856ca64fbc16}\label{cz2m_8cpp_ae6f7178fc35327a981af856ca64fbc16} 
\index{cz2m.cpp@{cz2m.cpp}!row\_echelon@{row\_echelon}}
\index{row\_echelon@{row\_echelon}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{row\_echelon()}{row\_echelon()}}
{\footnotesize\ttfamily py\+::array row\+\_\+echelon (\begin{DoxyParamCaption}\item[{py\+::array}]{voids,  }\item[{int}]{num\+\_\+qubits }\end{DoxyParamCaption})}



applies Gauss-\/\+Jordan elimination on a binary matrix to produce row echelon form 


\begin{DoxyParams}{Parameters}
{\em voids} & \\
\hline
{\em num\+\_\+qubits} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array 
\end{DoxyReturn}
\Hypertarget{cz2m_8cpp_ac4ad30cf11f525fd9d8edf274e2b746f}\label{cz2m_8cpp_ac4ad30cf11f525fd9d8edf274e2b746f} 
\index{cz2m.cpp@{cz2m.cpp}!sparse\_matrix\_from\_zx\_voids@{sparse\_matrix\_from\_zx\_voids}}
\index{sparse\_matrix\_from\_zx\_voids@{sparse\_matrix\_from\_zx\_voids}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{sparse\_matrix\_from\_zx\_voids()}{sparse\_matrix\_from\_zx\_voids()}}
{\footnotesize\ttfamily std\+::tuple$<$ std\+::vector$<$ int $>$, std\+::vector$<$ int $>$, std\+::vector$<$ std\+::complex$<$ double $>$ $>$ $>$ sparse\+\_\+matrix\+\_\+from\+\_\+zx\+\_\+voids (\begin{DoxyParamCaption}\item[{py\+::array}]{z\+\_\+voids,  }\item[{py\+::array}]{x\+\_\+voids,  }\item[{int}]{num\+\_\+qubits }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_a9462b2d1d2e54e82ad72c6d30f03230c}\label{cz2m_8cpp_a9462b2d1d2e54e82ad72c6d30f03230c} 
\index{cz2m.cpp@{cz2m.cpp}!tensor@{tensor}}
\index{tensor@{tensor}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{tensor()}{tensor()}}
{\footnotesize\ttfamily py\+::tuple tensor (\begin{DoxyParamCaption}\item[{py\+::array}]{z2,  }\item[{py\+::array}]{x2,  }\item[{py\+::array}]{z1,  }\item[{py\+::array}]{x1 }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_a375f5fbabed5082337c4f714f68bedd3}\label{cz2m_8cpp_a375f5fbabed5082337c4f714f68bedd3} 
\index{cz2m.cpp@{cz2m.cpp}!to\_matrix@{to\_matrix}}
\index{to\_matrix@{to\_matrix}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{to\_matrix()}{to\_matrix()}}
{\footnotesize\ttfamily py\+::array\+\_\+t$<$ std\+::complex$<$ double $>$ $>$ to\+\_\+matrix (\begin{DoxyParamCaption}\item[{py\+::array}]{z\+\_\+voids,  }\item[{py\+::array}]{x\+\_\+voids,  }\item[{int}]{num\+\_\+qubits }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em z\+\_\+voids} & \\
\hline
{\em x\+\_\+voids} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array\+\_\+t$<$std\+::complex$<$double$>$$>$ 
\end{DoxyReturn}
\Hypertarget{cz2m_8cpp_a12fbfe079cede36f161a30220eec6d97}\label{cz2m_8cpp_a12fbfe079cede36f161a30220eec6d97} 
\index{cz2m.cpp@{cz2m.cpp}!transpose@{transpose}}
\index{transpose@{transpose}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{transpose()}{transpose()}}
{\footnotesize\ttfamily py\+::array transpose (\begin{DoxyParamCaption}\item[{py\+::array}]{voids,  }\item[{int64\+\_\+t}]{num\+\_\+bits }\end{DoxyParamCaption})}



Transposes a technically 1D array of voids by interpreting it as a 2D array of bits. In other words, if the input array has shape (M,) and each element has N bits, the output array will have shape (N, M), where the rows correspond to the bits of the input elements. 

If input is\+: \mbox{[}0110, 1001, 1111\mbox{]}

then output will be\+: \mbox{[}011, 101, 101, 011\mbox{]}


\begin{DoxyParams}{Parameters}
{\em voids} & Input array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array Transposed array with minimal dtype 
\end{DoxyReturn}
\Hypertarget{cz2m_8cpp_aabe6109d5005c80e869f322975d474a4}\label{cz2m_8cpp_aabe6109d5005c80e869f322975d474a4} 
\index{cz2m.cpp@{cz2m.cpp}!unique@{unique}}
\index{unique@{unique}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily py\+::object unique (\begin{DoxyParamCaption}\item[{py\+::array}]{zx\+\_\+voids,  }\item[{bool}]{return\+\_\+index,  }\item[{bool}]{return\+\_\+inverse,  }\item[{bool}]{return\+\_\+counts }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8cpp_ae4da4fa68c447ad16c8312e9e6938628}\label{cz2m_8cpp_ae4da4fa68c447ad16c8312e9e6938628} 
\index{cz2m.cpp@{cz2m.cpp}!unordered\_unique@{unordered\_unique}}
\index{unordered\_unique@{unordered\_unique}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{unordered\_unique()}{unordered\_unique()}}
{\footnotesize\ttfamily py\+::tuple unordered\+\_\+unique (\begin{DoxyParamCaption}\item[{py\+::array}]{zx\+\_\+voids }\end{DoxyParamCaption})}



This is a very early test implementation of unordered unique. It finds unique rows in a Num\+Py 2D array by mapping the zx\+\_\+voids to a hashmap. Thus, two identical rows will be encoded to the same key via the hashing function and ensures a fast execution time. 

This function is heavily inspired by Qiskit\textquotesingle{}s Rust function of the same name. \href{https://github.com/Qiskit/qiskit/blob/main/crates/quantum_info/src/sparse_pauli_op.rs\#L54}{\texttt{ https\+://github.\+com/\+Qiskit/qiskit/blob/main/crates/quantum\+\_\+info/src/sparse\+\_\+pauli\+\_\+op.\+rs\#\+L54}}

\begin{DoxyAttention}{Attention}
Does not work for higher dimensions. 
\end{DoxyAttention}

\begin{DoxyParams}{Parameters}
{\em zx\+\_\+voids} & Both Z and X voids stiched together \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::tuple Returns (indices, inverse). Indices gives the index of each unique row from zx\+\_\+voids. Inverse is the indices to remake the input array from only its unique elements. 
\end{DoxyReturn}
\Hypertarget{cz2m_8cpp_a5eca29d13c97b572644a145d68451347}\label{cz2m_8cpp_a5eca29d13c97b572644a145d68451347} 
\index{cz2m.cpp@{cz2m.cpp}!z2\_to\_uint8@{z2\_to\_uint8}}
\index{z2\_to\_uint8@{z2\_to\_uint8}!cz2m.cpp@{cz2m.cpp}}
\doxysubsubsection{\texorpdfstring{z2\_to\_uint8()}{z2\_to\_uint8()}}
{\footnotesize\ttfamily py\+::array\+\_\+t$<$ uint8\+\_\+t $>$ z2\+\_\+to\+\_\+uint8 (\begin{DoxyParamCaption}\item[{py\+::array}]{z2r,  }\item[{int}]{num\+\_\+bits }\end{DoxyParamCaption})}

