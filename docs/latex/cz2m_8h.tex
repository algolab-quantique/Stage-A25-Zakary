\doxysection{z2r\+\_\+accel/\+\_\+core/include/cz2m.h File Reference}
\hypertarget{cz2m_8h}{}\label{cz2m_8h}\index{z2r\_accel/\_core/include/cz2m.h@{z2r\_accel/\_core/include/cz2m.h}}
{\ttfamily \#include $<$pybind11/numpy.\+h$>$}\newline
{\ttfamily \#include $<$pybind11/pybind11.\+h$>$}\newline
{\ttfamily \#include $<$complex$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$cstring$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$numeric$>$}\newline
{\ttfamily \#include $<$random$>$}\newline
{\ttfamily \#include $<$unordered\+\_\+map$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include "{}bitops.\+h"{}}\newline
Include dependency graph for cz2m.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{cz2m_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{cz2m_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{cz2m_8h_a8517b0cb68055ed7ceb0a5ff090f1205}{FUNC\+\_\+\+THRESHOLD\+\_\+\+PARALLEL}}~100000
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8h_a9462b2d1d2e54e82ad72c6d30f03230c}{tensor}} (py\+::array z2, py\+::array x2, py\+::array z1, py\+::array x1)
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8h_a66c4da901dc2803db3fd403a21934220}{compose}} (py\+::array z1, py\+::array x1, py\+::array z2, py\+::array x2)
\item 
py\+::array\+\_\+t$<$ bool $>$ \mbox{\hyperlink{cz2m_8h_a0f8b9ce6d2fd5c3b15c38b12727994f9}{bitwise\+\_\+commute\+\_\+with}} (py\+::array z1, py\+::array x1, py\+::array z2, py\+::array x2)
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8h_a0495c869623fb769f74386e502b297fc}{random\+\_\+zx\+\_\+strings}} (const std\+::vector$<$ size\+\_\+t $>$ \&shape)
\item 
py\+::object \mbox{\hyperlink{cz2m_8h_a6147faad379edac00e339de56b512a54}{unique}} (py\+::array zx\+\_\+voids, bool return\+\_\+index=false, bool return\+\_\+inverse=false, bool return\+\_\+counts=false)
\item 
py\+::tuple \mbox{\hyperlink{cz2m_8h_ae4da4fa68c447ad16c8312e9e6938628}{unordered\+\_\+unique}} (py\+::array zx\+\_\+voids)
\begin{DoxyCompactList}\small\item\em This is a very early test implementation of unordered unique. It finds unique rows in a Num\+Py 2D array by mapping the zx\+\_\+voids to a hashmap. Thus, two identical rows will be encoded to the same key via the hashing function and ensures a fast execution time. \end{DoxyCompactList}\item 
py\+::array \mbox{\hyperlink{cz2m_8h_ae6f7178fc35327a981af856ca64fbc16}{row\+\_\+echelon}} (py\+::array voids, int num\+\_\+qubits)
\begin{DoxyCompactList}\small\item\em applies Gauss-\/\+Jordan elimination on a binary matrix to produce row echelon form \end{DoxyCompactList}\item 
std\+::tuple$<$ std\+::vector$<$ int $>$, std\+::vector$<$ int $>$, std\+::vector$<$ std\+::complex$<$ double $>$ $>$ $>$ \mbox{\hyperlink{cz2m_8h_ac4ad30cf11f525fd9d8edf274e2b746f}{sparse\+\_\+matrix\+\_\+from\+\_\+zx\+\_\+voids}} (py\+::array z\+\_\+voids, py\+::array x\+\_\+voids, int num\+\_\+qubits)
\item 
std\+::vector$<$ std\+::complex$<$ double $>$ $>$ \mbox{\hyperlink{cz2m_8h_aac70a6a63284d6acd98f2c5cf2c67b0f}{get\+\_\+phases}} (py\+::array z\+\_\+voids, py\+::array x\+\_\+voids)
\item 
py\+::array\+\_\+t$<$ std\+::complex$<$ double $>$ $>$ \mbox{\hyperlink{cz2m_8h_a375f5fbabed5082337c4f714f68bedd3}{to\+\_\+matrix}} (py\+::array z\+\_\+voids, py\+::array x\+\_\+voids, int num\+\_\+qubits)
\item 
py\+::array \mbox{\hyperlink{cz2m_8h_ac8b462857cd8418f8967e4c5d3c31a48}{transpose}} (py\+::array voids, int64\+\_\+t num\+\_\+bits=-\/1)
\begin{DoxyCompactList}\small\item\em Transposes a technically 1D array of voids by interpreting it as a 2D array of bits. In other words, if the input array has shape (M,) and each element has N bits, the output array will have shape (N, M), where the rows correspond to the bits of the input elements. \end{DoxyCompactList}\item 
py\+::array \mbox{\hyperlink{cz2m_8h_a3c6e4cb97bf8045d53f0c6d4b48e834c}{matmul}} (py\+::array z2r\+\_\+a, py\+::array z2r\+\_\+b, int a\+\_\+num\+\_\+qubits, int b\+\_\+num\+\_\+qubits)
\begin{DoxyCompactList}\small\item\em Matrix multiplication of two void arrays (technically 1D), interpreted as 2D bit matrices. \end{DoxyCompactList}\item 
py\+::array \mbox{\hyperlink{cz2m_8h_abc190cf6fce33b858a0782c6058f86eb}{concatenate}} (py\+::array x1, py\+::array x2, int axis=0)
\item 
py\+::array\+\_\+t$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{cz2m_8h_ab5a4be27682ccf717b9522eb24bba423}{z2\+\_\+to\+\_\+uint8}} (py\+::array z2r, int num\+\_\+qubits)
\item 
py\+::array \mbox{\hyperlink{cz2m_8h_a29cded3e3faaca6962f8193aaaf35545}{gauss\+\_\+jordan\+\_\+inverse}} (py\+::array matrix, int num\+\_\+bits)
\begin{DoxyCompactList}\small\item\em Calculates the inverse of a matrix (if possible) using Gauss-\/\+Jordan elimination. This function will not work on a matrix if \+: \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\Hypertarget{cz2m_8h_a8517b0cb68055ed7ceb0a5ff090f1205}\label{cz2m_8h_a8517b0cb68055ed7ceb0a5ff090f1205} 
\index{cz2m.h@{cz2m.h}!FUNC\_THRESHOLD\_PARALLEL@{FUNC\_THRESHOLD\_PARALLEL}}
\index{FUNC\_THRESHOLD\_PARALLEL@{FUNC\_THRESHOLD\_PARALLEL}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{FUNC\_THRESHOLD\_PARALLEL}{FUNC\_THRESHOLD\_PARALLEL}}
{\footnotesize\ttfamily \#define FUNC\+\_\+\+THRESHOLD\+\_\+\+PARALLEL~100000}



\doxysubsection{Function Documentation}
\Hypertarget{cz2m_8h_a0f8b9ce6d2fd5c3b15c38b12727994f9}\label{cz2m_8h_a0f8b9ce6d2fd5c3b15c38b12727994f9} 
\index{cz2m.h@{cz2m.h}!bitwise\_commute\_with@{bitwise\_commute\_with}}
\index{bitwise\_commute\_with@{bitwise\_commute\_with}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{bitwise\_commute\_with()}{bitwise\_commute\_with()}}
{\footnotesize\ttfamily py\+::array\+\_\+t$<$ bool $>$ bitwise\+\_\+commute\+\_\+with (\begin{DoxyParamCaption}\item[{py\+::array}]{z1,  }\item[{py\+::array}]{x1,  }\item[{py\+::array}]{z2,  }\item[{py\+::array}]{x2 }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_a66c4da901dc2803db3fd403a21934220}\label{cz2m_8h_a66c4da901dc2803db3fd403a21934220} 
\index{cz2m.h@{cz2m.h}!compose@{compose}}
\index{compose@{compose}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{compose()}{compose()}}
{\footnotesize\ttfamily py\+::tuple compose (\begin{DoxyParamCaption}\item[{py\+::array}]{z1,  }\item[{py\+::array}]{x1,  }\item[{py\+::array}]{z2,  }\item[{py\+::array}]{x2 }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_abc190cf6fce33b858a0782c6058f86eb}\label{cz2m_8h_abc190cf6fce33b858a0782c6058f86eb} 
\index{cz2m.h@{cz2m.h}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{concatenate()}{concatenate()}}
{\footnotesize\ttfamily py\+::array concatenate (\begin{DoxyParamCaption}\item[{py\+::array}]{x1,  }\item[{py\+::array}]{x2,  }\item[{int}]{axis = {\ttfamily 0} }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_a29cded3e3faaca6962f8193aaaf35545}\label{cz2m_8h_a29cded3e3faaca6962f8193aaaf35545} 
\index{cz2m.h@{cz2m.h}!gauss\_jordan\_inverse@{gauss\_jordan\_inverse}}
\index{gauss\_jordan\_inverse@{gauss\_jordan\_inverse}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{gauss\_jordan\_inverse()}{gauss\_jordan\_inverse()}}
{\footnotesize\ttfamily py\+::array gauss\+\_\+jordan\+\_\+inverse (\begin{DoxyParamCaption}\item[{py\+::array}]{z2r,  }\item[{int}]{num\+\_\+bits }\end{DoxyParamCaption})}



Calculates the inverse of a matrix (if possible) using Gauss-\/\+Jordan elimination. This function will not work on a matrix if \+: 


\begin{DoxyItemize}
\item It is not "{}2\+D"{}, as in a 1D list of packed voids
\item It is not "{}square"{} (num\+\_\+qubits == number of rows)
\item It is inconsistant with its dtype and num\+\_\+qubits
\item It is is singular, i.\+e inatly does not have a inverse If an input is bad, a runtime error will be thrown and function exited. TODO\+: rename function variables to something less ass
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em z2r} & \\
\hline
{\em num\+\_\+bits} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array 
\end{DoxyReturn}
\Hypertarget{cz2m_8h_aac70a6a63284d6acd98f2c5cf2c67b0f}\label{cz2m_8h_aac70a6a63284d6acd98f2c5cf2c67b0f} 
\index{cz2m.h@{cz2m.h}!get\_phases@{get\_phases}}
\index{get\_phases@{get\_phases}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{get\_phases()}{get\_phases()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::complex$<$ double $>$ $>$ get\+\_\+phases (\begin{DoxyParamCaption}\item[{py\+::array}]{z\+\_\+voids,  }\item[{py\+::array}]{x\+\_\+voids }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_a3c6e4cb97bf8045d53f0c6d4b48e834c}\label{cz2m_8h_a3c6e4cb97bf8045d53f0c6d4b48e834c} 
\index{cz2m.h@{cz2m.h}!matmul@{matmul}}
\index{matmul@{matmul}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{matmul()}{matmul()}}
{\footnotesize\ttfamily py\+::array matmul (\begin{DoxyParamCaption}\item[{py\+::array}]{z2r\+\_\+a,  }\item[{py\+::array}]{z2r\+\_\+b,  }\item[{int}]{a\+\_\+num\+\_\+qubits,  }\item[{int}]{b\+\_\+num\+\_\+qubits }\end{DoxyParamCaption})}



Matrix multiplication of two void arrays (technically 1D), interpreted as 2D bit matrices. 


\begin{DoxyParams}{Parameters}
{\em z2r\+\_\+a} & \\
\hline
{\em z2r\+\_\+b} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array 
\end{DoxyReturn}
\Hypertarget{cz2m_8h_a0495c869623fb769f74386e502b297fc}\label{cz2m_8h_a0495c869623fb769f74386e502b297fc} 
\index{cz2m.h@{cz2m.h}!random\_zx\_strings@{random\_zx\_strings}}
\index{random\_zx\_strings@{random\_zx\_strings}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{random\_zx\_strings()}{random\_zx\_strings()}}
{\footnotesize\ttfamily py\+::tuple random\+\_\+zx\+\_\+strings (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{shape }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_ae6f7178fc35327a981af856ca64fbc16}\label{cz2m_8h_ae6f7178fc35327a981af856ca64fbc16} 
\index{cz2m.h@{cz2m.h}!row\_echelon@{row\_echelon}}
\index{row\_echelon@{row\_echelon}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{row\_echelon()}{row\_echelon()}}
{\footnotesize\ttfamily py\+::array row\+\_\+echelon (\begin{DoxyParamCaption}\item[{py\+::array}]{voids,  }\item[{int}]{num\+\_\+qubits }\end{DoxyParamCaption})}



applies Gauss-\/\+Jordan elimination on a binary matrix to produce row echelon form 


\begin{DoxyParams}{Parameters}
{\em voids} & \\
\hline
{\em num\+\_\+qubits} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array 
\end{DoxyReturn}
\Hypertarget{cz2m_8h_ac4ad30cf11f525fd9d8edf274e2b746f}\label{cz2m_8h_ac4ad30cf11f525fd9d8edf274e2b746f} 
\index{cz2m.h@{cz2m.h}!sparse\_matrix\_from\_zx\_voids@{sparse\_matrix\_from\_zx\_voids}}
\index{sparse\_matrix\_from\_zx\_voids@{sparse\_matrix\_from\_zx\_voids}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{sparse\_matrix\_from\_zx\_voids()}{sparse\_matrix\_from\_zx\_voids()}}
{\footnotesize\ttfamily std\+::tuple$<$ std\+::vector$<$ int $>$, std\+::vector$<$ int $>$, std\+::vector$<$ std\+::complex$<$ double $>$ $>$ $>$ sparse\+\_\+matrix\+\_\+from\+\_\+zx\+\_\+voids (\begin{DoxyParamCaption}\item[{py\+::array}]{z\+\_\+voids,  }\item[{py\+::array}]{x\+\_\+voids,  }\item[{int}]{num\+\_\+qubits }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_a9462b2d1d2e54e82ad72c6d30f03230c}\label{cz2m_8h_a9462b2d1d2e54e82ad72c6d30f03230c} 
\index{cz2m.h@{cz2m.h}!tensor@{tensor}}
\index{tensor@{tensor}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{tensor()}{tensor()}}
{\footnotesize\ttfamily py\+::tuple tensor (\begin{DoxyParamCaption}\item[{py\+::array}]{z2,  }\item[{py\+::array}]{x2,  }\item[{py\+::array}]{z1,  }\item[{py\+::array}]{x1 }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_a375f5fbabed5082337c4f714f68bedd3}\label{cz2m_8h_a375f5fbabed5082337c4f714f68bedd3} 
\index{cz2m.h@{cz2m.h}!to\_matrix@{to\_matrix}}
\index{to\_matrix@{to\_matrix}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{to\_matrix()}{to\_matrix()}}
{\footnotesize\ttfamily py\+::array\+\_\+t$<$ std\+::complex$<$ double $>$ $>$ to\+\_\+matrix (\begin{DoxyParamCaption}\item[{py\+::array}]{z\+\_\+voids,  }\item[{py\+::array}]{x\+\_\+voids,  }\item[{int}]{num\+\_\+qubits }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em z\+\_\+voids} & \\
\hline
{\em x\+\_\+voids} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array\+\_\+t$<$std\+::complex$<$double$>$$>$ 
\end{DoxyReturn}
\Hypertarget{cz2m_8h_ac8b462857cd8418f8967e4c5d3c31a48}\label{cz2m_8h_ac8b462857cd8418f8967e4c5d3c31a48} 
\index{cz2m.h@{cz2m.h}!transpose@{transpose}}
\index{transpose@{transpose}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{transpose()}{transpose()}}
{\footnotesize\ttfamily py\+::array transpose (\begin{DoxyParamCaption}\item[{py\+::array}]{voids,  }\item[{int64\+\_\+t}]{num\+\_\+bits }\end{DoxyParamCaption})}



Transposes a technically 1D array of voids by interpreting it as a 2D array of bits. In other words, if the input array has shape (M,) and each element has N bits, the output array will have shape (N, M), where the rows correspond to the bits of the input elements. 

If input is\+: \mbox{[}0110, 1001, 1111\mbox{]}

then output will be\+: \mbox{[}011, 101, 101, 011\mbox{]}


\begin{DoxyParams}{Parameters}
{\em voids} & Input array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::array Transposed array with minimal dtype 
\end{DoxyReturn}
\Hypertarget{cz2m_8h_a6147faad379edac00e339de56b512a54}\label{cz2m_8h_a6147faad379edac00e339de56b512a54} 
\index{cz2m.h@{cz2m.h}!unique@{unique}}
\index{unique@{unique}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily py\+::object unique (\begin{DoxyParamCaption}\item[{py\+::array}]{zx\+\_\+voids,  }\item[{bool}]{return\+\_\+index = {\ttfamily false},  }\item[{bool}]{return\+\_\+inverse = {\ttfamily false},  }\item[{bool}]{return\+\_\+counts = {\ttfamily false} }\end{DoxyParamCaption})}

\Hypertarget{cz2m_8h_ae4da4fa68c447ad16c8312e9e6938628}\label{cz2m_8h_ae4da4fa68c447ad16c8312e9e6938628} 
\index{cz2m.h@{cz2m.h}!unordered\_unique@{unordered\_unique}}
\index{unordered\_unique@{unordered\_unique}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{unordered\_unique()}{unordered\_unique()}}
{\footnotesize\ttfamily py\+::tuple unordered\+\_\+unique (\begin{DoxyParamCaption}\item[{py\+::array}]{zx\+\_\+voids }\end{DoxyParamCaption})}



This is a very early test implementation of unordered unique. It finds unique rows in a Num\+Py 2D array by mapping the zx\+\_\+voids to a hashmap. Thus, two identical rows will be encoded to the same key via the hashing function and ensures a fast execution time. 

This function is heavily inspired by Qiskit\textquotesingle{}s Rust function of the same name. \href{https://github.com/Qiskit/qiskit/blob/main/crates/quantum_info/src/sparse_pauli_op.rs\#L54}{\texttt{ https\+://github.\+com/\+Qiskit/qiskit/blob/main/crates/quantum\+\_\+info/src/sparse\+\_\+pauli\+\_\+op.\+rs\#\+L54}}

\begin{DoxyAttention}{Attention}
Does not work for higher dimensions. 
\end{DoxyAttention}

\begin{DoxyParams}{Parameters}
{\em zx\+\_\+voids} & Both Z and X voids stiched together \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
py\+::tuple Returns (indices, inverse). Indices gives the index of each unique row from zx\+\_\+voids. Inverse is the indices to remake the input array from only its unique elements. 
\end{DoxyReturn}
\Hypertarget{cz2m_8h_ab5a4be27682ccf717b9522eb24bba423}\label{cz2m_8h_ab5a4be27682ccf717b9522eb24bba423} 
\index{cz2m.h@{cz2m.h}!z2\_to\_uint8@{z2\_to\_uint8}}
\index{z2\_to\_uint8@{z2\_to\_uint8}!cz2m.h@{cz2m.h}}
\doxysubsubsection{\texorpdfstring{z2\_to\_uint8()}{z2\_to\_uint8()}}
{\footnotesize\ttfamily py\+::array\+\_\+t$<$ uint8\+\_\+t $>$ z2\+\_\+to\+\_\+uint8 (\begin{DoxyParamCaption}\item[{py\+::array}]{z2r,  }\item[{int}]{num\+\_\+qubits }\end{DoxyParamCaption})}

